<!doctype html><html lang=en-us><head><meta charset=utf-8><title>The Actor Model</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="We see planet-wide possibilities."><meta name=author content="Rotational Labs, LLC"><meta name=generator content="Hugo 0.81.0"><link rel=stylesheet href=https://rotational.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://rotational.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://rotational.io/plugins/magnific-popup/magnific-popup.css><link rel=stylesheet href=https://rotational.io/plugins/slick/slick.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento+Sans:400,700&display=swap"><link rel=stylesheet href=https://rotational.io/css/style.min.css media=screen><link rel=stylesheet href=https://rotational.io/css/custom.min.css media=screen><link rel="shortcut icon" href=https://rotational.io/images/favicon.png type=image/x-icon><link rel=icon href=https://rotational.io/images/favicon.png type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-2FKX6CWJHW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-2FKX6CWJHW')</script></head><body id=body data-spy=scroll data-target=.navbar data-offset=55><div id=content><section class="sticky-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-dark"><a class="navbar-brand p-0" href=/><img class=lozad data-src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a>
<button class="navbar-toggler rounded-0" type=button data-toggle=collapse data-target=#navigation>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://rotational.io/#about>about</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#services>services</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#team>team</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/blog>blog</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#contact>contact</a></li></ul><select id=select-language onchange="location=this.value"><option id=en value=https://rotational.io/blog/2018-08-03-actor-model/ selected>En</option><option id=fr value=https://rotational.io/fr/blog/2018-08-03-actor-model/>Fr</option></select></div></nav></div></section><section class=section><div class=container><div class=row><div class="col-lg-8 offset-lg-2 text-center"><h1>The Actor Model</h1><ul class="list-inline mb-50"><li class=list-inline-item><a href=/author/benjamin-bengfort/>Benjamin Bengfort</a></li><li class=list-inline-item>Friday, Aug 3, 2018</li></ul><img class="img-fluid mb-50 lozad" data-src=https://rotational.io/images/blog/leaf.jpg alt=blog-image></div><div class="col-lg-8 offset-lg-2"><div class=post-single-content><p>Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can <a href=https://bbengfort.github.io/2017/02/synchronizing-structs/>ensure structs are thread-safe</a>, however in Go, the strong preference for <a href=https://blog.golang.org/share-memory-by-communicating>synchronization is communication</a>. In either case Go programs can quickly become locks upon locks or morasses of channels, incurring performance penalties at each synchronization point.</p><p>The <a href=https://en.wikipedia.org/wiki/Actor_model>Actor Model</a> is a solution for reasoning about concurrency in distributed systems that helps eliminate unnecessary synchronization. In the actor model, we consider our system to be composed of <em>actors</em>, computational primitives that have a private state, can send and receive messages, and perform computations based on those messages. The key is that a system is composed of many actors and actors do not share memory, they have to communicate with messaging. Although Go does not provide first class actor primitives like languages such as Akka or Erlang, this does fit in well with the <a href=http://www.usingcsp.com/>CSP</a> principle.</p><p>In the next few posts, I&rsquo;ll explore implementing the Actor model in Go for a simple distributed system that allows clients to make requests and periodically synchronizes its state to its peers. The model is shown below:</p><p><img src=/images/2018-08-03-actor-model.png alt="The Actor Model"></p><h2 id=actors>Actors</h2><p>An actor is a process or a thread that has the ability to send and receive messages. When an actor receives a message it can do one of three things:</p><ol><li>Create new actors</li><li>Send messages to known actors</li><li>Can designate how you handle the next message</li></ol><p>At first glance we may think that actors are only created at the beginning of a program, e.g. the &ldquo;main&rdquo; actor or the instantiation of a program-long ticker actor that sends periodic messages and can receive start and stop messages. However, anytime a go programmer executes a new go routine, there is the possibility of a new actor being created. In our example, we&rsquo;ll explore how a server creates temporary actors to handle single requests from clients.</p><p>Sending messages to known actors allows an actor to synchronize or share state with other go routines in the same process, other processes on the same machine, or even processes on other machines. As a result, actors are a natural framework for creating distributed systems. In our example we&rsquo;ll send messages both with channels as well as using <a href=https://grpc.io/>gRPC</a> for network communications.</p><p>The most important thing to understand about actor communication is that although actors run concurrently, they will only process messages sequentially in the order which they are received. Actors send messages asynchronously (e.g. an actor isn&rsquo;t blocked while waiting for another actor to receive the message). This means that messages need to be stored while the actor is processing other messages; this storage is usually called a &ldquo;mailbox&rdquo;. We&rsquo;ll implement mailboxes with buffered channels in this post.</p><p>Deciding how to handle the next message is a general way for saying that actors &ldquo;do something&rdquo; with messages, usually by modifying their state, and that it is something &ldquo;interesting enough&rdquo; that it impacts how the next message is handled. This implies a couple of things:</p><ul><li>Actors have an internal state and memory</li><li>Actors mutate their state based on messages</li><li>How an actor responds depends on the order of messages received</li><li>Actors can shutdown or stop</li></ul><p>For the rest of the posts, we&rsquo;ll consider a simple service that hands out monotonically increasing, unique identities to clients called <strong>Ipseity</strong>. If the actor receives a <code>next()</code> message, it increments it&rsquo;s local counter (mutating it&rsquo;s internal state) ensuring that the next message always returns a monotonically increasing number. If it receives an <code>update(id)</code> message, it updates it&rsquo;s internal state to specified id if it is larger than its internal id, allowing it to synchronize with remote peers (in an eventually consistent fashion).</p><h3 id=event-model>Event Model</h3><p>In order to reduce confusion between network messages and actor messages, I prefer to use the term &ldquo;event&rdquo; when referring to messages sent between actors. This also allows us to reason about actors as implementing an event loop, another common distributed systems design paradigm. It is important to note that <a href=https://www.quora.com/What-are-the-relative-tradeoffs-between-the-actors-model-and-an-event-driven-architecture>“actors are a specialized, opinionated implementation of an event driven architecture”</a>, which means the actor model is a subset of event architectures, such as the <a href=https://bbengfort.github.io/2017/07/event-dispatcher/>dispatcher model</a>.</p><p>I realize this does cause a bit of cognitive overhead, but this pays off when complex systems with many event types can be traced, showing a serial order of events handled by an actor. So for now, we&rsquo;ll consider an event a message that can be &ldquo;dispatched&rdquo; (sent) to other actors, and &ldquo;handled&rdquo; (received) by an actor, one at a time.</p><p>Events are described by their type, which determines what data the event contains and how it should be handled by the actor. In Go, event types can be implemented as an enumeration by extending the <code>uint16</code> type as follows:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#999;font-style:italic>// Event types represented in Ipseity
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>const</span> (
    UnknownEvent EventType = <span style=color:#6ab825;font-weight:700>iota</span>
    IdentityRequest
    SyncTimeout
    SyncRequest
    SyncReply
)

<span style=color:#999;font-style:italic>// String names of event types
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>var</span> eventTypeStrings = [...]<span style=color:#6ab825;font-weight:700>string</span>{
    <span style=color:#ed9d13>&#34;unknown&#34;</span>, <span style=color:#ed9d13>&#34;identityRequest&#34;</span>, <span style=color:#ed9d13>&#34;syncTimeout&#34;</span>, <span style=color:#ed9d13>&#34;syncRequest&#34;</span>, <span style=color:#ed9d13>&#34;syncReply&#34;</span>,
}

<span style=color:#999;font-style:italic>// EventType is an enumeration of the kind of events that actors handle
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>type</span> EventType <span style=color:#6ab825;font-weight:700>uint16</span>

<span style=color:#999;font-style:italic>// String returns the human readable name of the event type
</span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>func</span> (t EventType) <span style=color:#447fcf>String</span>() <span style=color:#6ab825;font-weight:700>string</span> {
    <span style=color:#6ab825;font-weight:700>if</span> <span style=color:#24909d>int</span>(t) &lt; <span style=color:#24909d>len</span>(eventTypeStrings) {
        <span style=color:#6ab825;font-weight:700>return</span> eventTypeStrings[t]
    }
    <span style=color:#6ab825;font-weight:700>return</span> eventTypeStrings[<span style=color:#3677a9>0</span>]
}
</code></pre></div><p>Events themselves are usually represented by an interface to allow for multiple event types with specialized functionality to be created in code. For simplicity here, however, I&rsquo;ll simply define a single event <code>struct</code> and we&rsquo;ll use type casting later in the code:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>type</span> Event <span style=color:#6ab825;font-weight:700>struct</span> {
    Type EventType
    Source <span style=color:#6ab825;font-weight:700>interface</span>{}
    Value <span style=color:#6ab825;font-weight:700>interface</span>{}
}
</code></pre></div><p>The <code>Source</code> of the event is the actor that is dispatching the event, and we&rsquo;ll primarily use this to store channels so that we can send messages (events) back to the actor. The <code>Value</code> of the event is any associated data that needs to be used by the actor processing the event.</p><h3 id=actor-interface>Actor Interface</h3><p>There are a lot of different types of actors including:</p><ul><li>Actors that run for the duration of the program</li><li>Actors that generate events but do not receive them</li><li>Actors that exist ephemerally to handle one or few events</li></ul><p>As a result it is difficult to describe an interface that handles all of these types generically. Instead we&rsquo;ll focus on the central actor of our application (called the &ldquo;Local Actor&rdquo; in the diagram above), which fulfills the first role (runs the duration of the program) and most completely describes the actor design.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>type</span> Actor <span style=color:#6ab825;font-weight:700>interface</span> {
    <span style=color:#447fcf>Listen</span>(addr <span style=color:#6ab825;font-weight:700>string</span>) <span style=color:#6ab825;font-weight:700>error</span> <span style=color:#999;font-style:italic>// Run the actor to listen for messages
</span><span style=color:#999;font-style:italic></span>    <span style=color:#447fcf>Dispatch</span>(Event) <span style=color:#6ab825;font-weight:700>error</span>     <span style=color:#999;font-style:italic>// Outside callers dispatch events to actor
</span><span style=color:#999;font-style:italic></span>    <span style=color:#447fcf>Handle</span>(Event) <span style=color:#6ab825;font-weight:700>error</span>       <span style=color:#999;font-style:italic>// Handle each event sequentially
</span><span style=color:#999;font-style:italic></span>}
</code></pre></div><p>As noted in the introduction and throughput appendix below, there are a number of ways to implement the actor interface that ensure events received by the <code>Dispatch</code> method are handled one at a time, in sequential order. Here, we&rsquo;ll use a a <a href=https://gobyexample.com/channel-buffering>buffered channel</a> as a mailbox of a fixed size, so that other actors that are dispatching events to this actor aren&rsquo;t blocked while the actor is handling other messages.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>type</span> ActorServer <span style=color:#6ab825;font-weight:700>struct</span> {
    pid      <span style=color:#6ab825;font-weight:700>int64</span>      <span style=color:#999;font-style:italic>// unique identity of the actor
</span><span style=color:#999;font-style:italic></span>    events   <span style=color:#6ab825;font-weight:700>chan</span> Event <span style=color:#999;font-style:italic>// mailbox to receive event dispatches
</span><span style=color:#999;font-style:italic></span>    sequence <span style=color:#6ab825;font-weight:700>int64</span>      <span style=color:#999;font-style:italic>// internal state, monotonically increasing identity
</span><span style=color:#999;font-style:italic></span>}
</code></pre></div><p>The <code>Listen</code> method starts the actor, (as well as a gRPC server on the specified <code>addr</code>, which we&rsquo;ll discuss later) and reads messages off the channel one at a time, executing the <code>Handle</code> method for each message before moving to the next message. <code>Listen</code> runs forever until the events channel is closed, e.g. when the program exits.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> (a *ActorServer) <span style=color:#447fcf>Listen</span>(addr <span style=color:#6ab825;font-weight:700>string</span>) <span style=color:#6ab825;font-weight:700>error</span> {
    <span style=color:#999;font-style:italic>// Initialize the events channel able to buffer 1024 messages
</span><span style=color:#999;font-style:italic></span>    a.events = <span style=color:#24909d>make</span>(<span style=color:#6ab825;font-weight:700>chan</span> Event, <span style=color:#3677a9>1024</span>)

    <span style=color:#999;font-style:italic>// Read events off of the channel sequentially
</span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>for</span> event := <span style=color:#6ab825;font-weight:700>range</span> a.events {
        <span style=color:#6ab825;font-weight:700>if</span> err := a.<span style=color:#447fcf>Handle</span>(event); err != <span style=color:#6ab825;font-weight:700>nil</span> {
            <span style=color:#6ab825;font-weight:700>return</span> err
        }
    }

    <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>nil</span>
}
</code></pre></div><p>The <code>Handle</code> method can create new actors, send messages, and determine how to respond to the next event. Generally it is just a jump table, passing the event to the correct event handling method:</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> (a *ActorServer) <span style=color:#447fcf>Handle</span>(e Event) <span style=color:#6ab825;font-weight:700>error</span> {
    <span style=color:#6ab825;font-weight:700>switch</span> e.<span style=color:#447fcf>Type</span>() {
    <span style=color:#6ab825;font-weight:700>case</span> IdentityRequest:
        <span style=color:#6ab825;font-weight:700>return</span> a.<span style=color:#447fcf>onIdentityRequest</span>(e)
    <span style=color:#6ab825;font-weight:700>case</span> SyncTimeout:
        <span style=color:#6ab825;font-weight:700>return</span> a.<span style=color:#447fcf>onSyncTimeout</span>(e)
    <span style=color:#6ab825;font-weight:700>case</span> SyncRequest:
        <span style=color:#6ab825;font-weight:700>return</span> a.<span style=color:#447fcf>onSyncRequest</span>(e)
    <span style=color:#6ab825;font-weight:700>case</span> SyncReply:
        <span style=color:#6ab825;font-weight:700>return</span> a.<span style=color:#447fcf>onSyncReply</span>(e)
    <span style=color:#6ab825;font-weight:700>default</span>:
        <span style=color:#6ab825;font-weight:700>return</span> fmt.<span style=color:#447fcf>Errorf</span>(<span style=color:#ed9d13>&#34;no handler identified for event %s&#34;</span>, e.<span style=color:#447fcf>Type</span>())
    }
}
</code></pre></div><p>The <code>Dispatch</code> method allows other actors to send events to the actor, by simply putting the event on the channel. When other go routines call <code>Dispatch</code> they won&rsquo;t be blocked, waiting for the actor to handle the event because of the buffer … unless the actor has been backed up so the buffer is full.</p><div class=highlight><pre style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#6ab825;font-weight:700>func</span> (a *ActorServer) <span style=color:#447fcf>Dispatch</span>(e Event) <span style=color:#6ab825;font-weight:700>error</span> {
    a.events &lt;- e
    <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#6ab825;font-weight:700>nil</span>
}
</code></pre></div><h2 id=next-steps>Next Steps</h2><p>In the next post (or two) we&rsquo;ll hook up a gRPC server to the actor so that it can serve identity requests to clients as well as send and respond to synchronization requests for remote actors. We&rsquo;ll also create a second go routine next to the actor process that issues synchronization timeouts on a periodic interval. Together, the complete system will be able to issue monotonically increasing identities in an eventually consistent fashion.</p><h2 id=other-resources>Other Resources</h2><p>For any discussion of Actors, it seems obligatory to include this very entertaining video of <a href=https://en.wikipedia.org/wiki/Carl_Hewitt>Carl Hewitt</a>, the inventor of the actor model, describing them on a white board with <a href=https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)>Erik Meijer</a> and <a href=https://g.co/kgs/MxoC3d>Clemens Szyperski</a>.</p><p>Other blog posts:</p><ul><li><a href=https://www.brianstorti.com/the-actor-model/>The actor model in 10 minutes</a></li><li><a href=https://www.doc.ic.ac.uk/~nd/surprise_97/journal/vol2/pjm2/>Why has the actor model not succeeded?</a></li><li><a href=https://www.oreilly.com/ideas/understanding-reactive-architecture-through-the-actor-model>Understanding reactive architecture through the actor model</a></li></ul><h2 id=appendix-throughput>Appendix: Throughput</h2><p>One of the biggest questions I had was whether or not the actor model introduced any performance issues over a regular mutex by serializing a wrapper event over a channel instead of directly locking the actor state. I tested the throughput for the following types of ipseity servers:</p><ul><li><strong>Simple</strong>: locks the whole server to increment the <code>sequence</code> and create the response to the client.</li><li><strong>Sequence</strong>: creates a sequence struct that is locked when incremented, but not when creating the response to the client.</li><li><strong>Actor</strong>: Uses the buffered channel actor model as described in this post.</li><li><strong>Locker</strong>: Implements the actor interface but instead of a buffered channel uses a mutex to serialize events.</li></ul><p><img src=/images/blog/2018-08-03-actor-throughput.png alt="Actor Throughput"></p><p>As you can see from the above benchmark, it does not appear that the actor model described in these posts adds overhead that penalizes performance.</p><p>The code for both the benchmark and the implementations of the servers above can be found at: <a href=https://github.com/bbengfort/ipseity/tree/multiactor>https://github.com/bbengfort/ipseity/tree/multiactor</a></p></div><div class=mt-5></div></div></div></div></section></div><footer id=footer class=section-bg><div class=container><div class="row wow fadeInUp" data-wow-duration=500ms><div class=col-xl-12><div class=social-icon><ul class=list-inline><li class=list-inline-item><a href=https://twitter.com/rotationalio><i class=ti-twitter-alt></i></a></li><li class=list-inline-item><a href=https://github.com/rotational.io><i class=ti-github></i></a></li><li class=list-inline-item><a href=https://www.linkedin.com/company/71689585/admin/><i class=ti-linkedin></i></a></li></ul></div><div class="copyright text-center"><a href=https://rotational.io/><img src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a><br><p>Copyright © 2021 Rotational Labs, LLC · Powered by <a href=https://gethugothemes.com>Hugo</a> · Theme by <a href=https://themefisher.com>Themefisher</a></p></div></div></div></div></footer><script src=https://rotational.io/plugins/jquery/jquery.min.js></script><script src=https://rotational.io/plugins/bootstrap/bootstrap.min.js></script><script src=https://rotational.io/plugins/slick/slick.min.js></script><script src=https://rotational.io/plugins/shuffle/shuffle.min.js></script><script src=https://rotational.io/plugins/magnific-popup/jquery.magnific-popup.min.js></script><script src=https://rotational.io/plugins/lazy-load/lozad.min.js></script><script src=https://rotational.io/plugins/google-map/map.js></script><script src=https://rotational.io/js/script.min.5db5ae6f88052715e823d7c52f3fa7a832565352b0f76c1d2cee2a3b564a0716fa9d51878a9965389c3d856f2d7c6330.js integrity=sha384-XbWub4gFJxXoI9fFLz+nqDJWU1Kw92wdLO4qO1ZKBxb6nVGHipllOJw9hW8tfGMw></script></body></html>