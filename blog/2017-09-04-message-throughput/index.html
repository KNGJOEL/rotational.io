<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Messaging Throughput gRPC vs. ZMQ</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Messaging Throughput gRPC vs. ZMQ"><meta name=author content="Rotational Labs, LLC"><meta name=generator content="Hugo 0.81.0"><link rel=stylesheet href=https://rotational.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://rotational.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://rotational.io/plugins/magnific-popup/magnific-popup.css><link rel=stylesheet href=https://rotational.io/plugins/slick/slick.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento+Sans:400,700&display=swap"><link rel=stylesheet href=https://rotational.io/css/style.min.css media=screen><link rel=stylesheet href=https://rotational.io/css/custom.min.css media=screen><link rel="shortcut icon" href=https://rotational.io/images/favicon.png type=image/x-icon><link rel=icon href=https://rotational.io/images/favicon.png type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-2FKX6CWJHW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-2FKX6CWJHW')</script></head><body id=body data-spy=scroll data-target=.navbar data-offset=55><div id=content><section class="sticky-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-dark"><a class="navbar-brand p-0" href=/><img class=lozad data-src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a>
<button class="navbar-toggler rounded-0" type=button data-toggle=collapse data-target=#navigation>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://rotational.io/#about>about</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#services>services</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#team>team</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/blog>blog</a></li><li class=nav-item><a class=nav-link href=https://rotational.io/#contact>contact</a></li></ul><select id=select-language onchange="location=this.value"><option id=en value=https://rotational.io/blog/2017-09-04-message-throughput/ selected>En</option><option id=fr value=https://rotational.io/fr/blog/2017-09-04-message-throughput/>Fr</option></select></div></nav></div></section><section class=section><div class=container><div class=row><div class="col-lg-8 offset-lg-2 text-center"><h1>Messaging Throughput gRPC vs. ZMQ</h1><ul class="list-inline mb-50"><li class=list-inline-item><a href=/author/benjamin-bengfort/>Benjamin Bengfort</a></li><li class=list-inline-item>Monday, Sep 4, 2017</li></ul><img class="img-fluid mb-50 lozad" data-src=https://rotational.io/images/blog/jungle_c.jpg alt=blog-image></div><div class="col-lg-8 offset-lg-2"><div class=post-single-content><p>Building distributed systems in Go requires an RPC or message framework of some sort. In the systems I build I prefer to pass messages serialized with <a href=https://developers.google.com/protocol-buffers/>protocol buffers</a> therefore a natural choice for me is <a href=https://grpc.io/>grpc</a>. The grpc library uses HTTP2 as a transport layer and provides a code generator based on the protocol buffer syntax making it very simple to use.</p><p>For more detailed control, the <a href=http://zeromq.org/>ZMQ</a> library is an excellent, low latency socket framework. ZMQ provides several communication patterns from basic REQ/REP (request/reply) to PUB/SUB (publish/subscribe). ZMQ is used at a lower level though, so more infrastructure per app needs to be built.</p><p>This leads to the obvious question: which RPC framework is faster? Here are the results:</p><p><img src=/images/blog/2017-09-08-echo-throughput.png alt="Echo Server Throughput"></p><p>These results show the message throughput of three echo servers that respond to a simple message with a response including a sequence number. Each server is running on its own EC2 micro instance with 1GB of memory and 1 vCPU. Each client is running on on an EC2 nano instance with 0.5GB of memory and 1 vCPU and are constantly sending messages at the server. The throughput is the number of messages per second the server can handle.</p><p>The servers are as follows:</p><ol><li><a href=https://github.com/bbengfort/rtreq/blob/master/server_sync.go>rep</a>: a server that implements a REQ/REP socket and simple handler.</li><li><a href=https://github.com/bbengfort/rtreq/blob/master/server_async.go>router</a>: a server that implements a REQ/ROUTER socket along with a DEALER/REP socket for 16 workers, connected via a proxy.</li><li><a href=https://github.com/bbengfort/echo/blob/master/server.go>grpc</a>: implements a gRPC service.</li></ol><p>The runner and results can be found <a href=https://github.com/bbengfort/go-rpc-throughput>here</a>.</p><h2 id=discussion>Discussion</h2><p>All the figures exhibit a standard shape for throughput - namely as more clients are added the throughput increases, but begins to tail off toward an asymptote. The asymptote represents the maximum number of messages a server can respond to without message latency. Generally speaking if a server can handle multiple clients at once, the throughput is higher.</p><p>The ZMQ REQ/ROUTER/PROXY/DEALER/REP server with 16 workers outperforms the gRPC server (it has a higher overall throughput). I hypothesize that this is because ZMQ does not have the overhead of HTTP and is in fact lighter weight code than gRPC since none of it is generated. It&rsquo;s unclear if adding more workers would improve the throughput of the ZMQ router server.</p><p>The performance of the REQ/REP server is a mystery. It&rsquo;s doing <em>way</em> better than the other two. This socket has very little overhead, so for fewer clients it should be performing better. However, this socket also blocks on a per-client basis. Both grpc and router are asynchronous and can handle multiple clients at a time suggesting that they should be much faster.</p></div><div class=mt-5></div></div></div></div></section></div><footer id=footer class=section-bg><div class=container><div class="row wow fadeInUp" data-wow-duration=500ms><div class=col-xl-12><div class=social-icon><ul class=list-inline><li class=list-inline-item><a href=https://twitter.com/rotationalio><i class=ti-twitter-alt></i></a></li><li class=list-inline-item><a href=https://github.com/rotational.io><i class=ti-github></i></a></li><li class=list-inline-item><a href=https://www.linkedin.com/company/71689585/admin/><i class=ti-linkedin></i></a></li></ul></div><div class="copyright text-center"><a href=https://rotational.io/><img src=https://rotational.io/images/logo.png alt="Rotational Labs" height=42></a><br><p>Copyright © 2021 Rotational Labs, LLC · Powered by <a href=https://gethugothemes.com>Hugo</a> · Theme by <a href=https://themefisher.com>Themefisher</a></p></div></div></div></div></footer><script src=https://rotational.io/plugins/jquery/jquery.min.js></script><script src=https://rotational.io/plugins/bootstrap/bootstrap.min.js></script><script src=https://rotational.io/plugins/slick/slick.min.js></script><script src=https://rotational.io/plugins/shuffle/shuffle.min.js></script><script src=https://rotational.io/plugins/magnific-popup/jquery.magnific-popup.min.js></script><script src=https://rotational.io/plugins/lazy-load/lozad.min.js></script><script src=https://rotational.io/plugins/google-map/map.js></script><script src=https://rotational.io/js/script.min.5db5ae6f88052715e823d7c52f3fa7a832565352b0f76c1d2cee2a3b564a0716fa9d51878a9965389c3d856f2d7c6330.js integrity=sha384-XbWub4gFJxXoI9fFLz+nqDJWU1Kw92wdLO4qO1ZKBxb6nVGHipllOJw9hW8tfGMw></script></body></html>